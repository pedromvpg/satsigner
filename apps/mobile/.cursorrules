[MOBILE RULES]

[i18n]
Strings should be localized. Add translation in en.json. Use the translation like: t('common.cancel')
Strings in i18n files should only be 1 level deep at most. Then use dots to separate like: "address": { "details.balance.confirmed": "Confirmed", "details.balance.title": "Balance" }

[Navigation]
We use expo-router. Follow expo-router best practices.
Use useLocalSearchParams with type annotation for type the params like: useLocalSearchParams<AccountSearchParams>(). Navigation searchParams types should be under mobile/types/navigation/searchParams

[State Management]
We use zustand for state management. Stores are under the store folder. Stores that need to persist, we use mmkvStorage (use createJSONStorage and persist functions from zustand)
We type our State and Actions separately like: type AuthState = {}; type AuthAction = {}
We recommend using derived types from state when typing actions like: setFirstTime: (firstTime: AuthState['firstTime']) => void
Use immer to mutate nested state in objects/arrays and a simple set for trivial state mutations.
Zustand should only be responsible to store and mutate state and not run external functions or business logic

Do not use function selectors in Zustand stores like: useStore(function (state) { return state.something })
Instead use direct selectors: useStore((state) => state.something)

Use useShallow with array selectors, not object destructuring:
✅ Correct: const [state1, action1] = useStore(useShallow((state) => [state.state1, state.action1]))
❌ Wrong: const { state1, action1 } = useStore(useShallow((state) => ({ state1: state.state1, action1: state.action1 })))

Use useShallow when selecting multiple pieces of state from the same store
For single state selection, use direct selector: const something = useStore((state) => state.something)

[React useEffect Guidelines]
Before using useEffect, read: [You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect)

Common cases where useEffect is NOT needed:

- Transforming data for rendering (use variables or useMemo instead)
- Handling user events (use event handlers instead)
- Resetting state when props change (use key prop or calculate during render)
- Updating state based on props/state changes (calculate during render)

Only use useEffect for:

- Synchronizing with external systems (APIs, DOM, third-party libraries)
- Cleanup that must happen when component unmounts

Prefer deriving state without useEffect when possible.

const name = `${firstName} ${lastName}`

For heavy computation, use useMemo:
const derivedValue = useMemo(() => calculateValue(deps), [deps])

See docs/pages/develop/store.mdx for more state management best practices

[Components]
Components and layouts are prefixed with "SS"
Follow the component anatomy & best practices described in docs/pages/develop/components.mdx
Don't add spaces between component/react native tags
Prioritize using already created layouts and components. Layouts components are under layouts folder and components under components folder
Do not add complex logic directly in JSX templates
Extract logic into separate functions or use useCallback for event handlers
Keep JSX clean and readable
Move business logic outside of render functions

[Pages]
Inside the app folder is where our pages are.
Prioritize using inline styles for overriding components defaults before creating const styles = StyleSheet.create
Organize the code inside the page - this is very important - first declare hooks, then use zustand stores, then useState and useMemo/useCallback then useEffects/useFocusEffect/function declarations - finally the jsx
Avoid creating unnecessary state with useState and overuse useEffect

[Storage]
Use storage/encrypted to store things in keychain securely

[API]
We put api logic inside api folder
Pages code should call these functions and local state (with useState)/zustand should handle the state

[Constants]
Add/update constants inside the constants folder

[Function Usage]
Use function keyword for function declarations and standalone functions
Use arrow functions for:

- Event handlers in JSX (onPress, onClick, etc.)
- Callback functions passed to hooks (useCallback, useMemo, etc.)
- Inline functions in component props
- Array methods (map, filter, reduce, etc.)

[Error Handling]
Use try-catch ONLY for operations outside our control:
✅ Correct: Network requests, clipboard operations, camera access, file I/O, NFC, external APIs
❌ Wrong: User input validation, account creation, data processing (validate inputs instead)

If error is not used, omit the parameter: catch { }
If error is used, name it appropriately: catch (error) { }
Never use underscore prefix like catch (\_error) { }
Never leave unused error variables

Always show user feedback with toast.error in catch blocks.
Do not cast the error like: error as Error.
Also, do not:
❌ Wrong: catch (error) { toast.error('Operation failed') }
❌ Wrong: catch (error) { /_ silent handling _/ }
❌ Wrong: catch { /_ no user feedback _/ }

For user input and business logic: Validate inputs properly:
✅ Correct: if (!isValidInput(input)) { toast.error('Invalid input'); return }

[Before commiting]
Remove console.logs
Run the linter: yarn lint:fix
Run the formatter: yarn format:fix
Run type-checking: yarn type-check
