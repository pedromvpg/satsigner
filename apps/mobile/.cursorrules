[MOBILE RULES]

[i18n]
Strings should be localized. Add translation in en.json. Use the translation like: t('common.cancel')
Strings in i18n files should only be 1 level deep at most. Then use dots to separate like: "address": { "details.balance.confirmed": "Confirmed", "details.balance.title": "Balance" }

[Navigation]
We use expo-router. Follow expo-router best practices.
Use useLocalSearchParams with type annotation for type the params like: useLocalSearchParams<AccountSearchParams>(). Navigation searchParams types should be under mobile/types/navigation/searchParams

[State Management]
We use zustand for state management. Stores are under the store folder. Stores that need to persist, we use mmkvStorage (use createJSONStorage and persist functions from zustand)
We type our State and Actions separately like: type AuthState = {}; type AuthAction = {}
We recommend using derived types from state when typing actions like: setFirstTime: (firstTime: AuthState['firstTime']) => void
Use immer to mutate nested state in objects/arrays and a simple set for trivial state mutations.
Zustand should only be responsible to store and mutate state and not run external functions or business logic
Use useShallow if you are selecting for that one piece of state from one store like: const [exampleState3, exampleAction5] = useBearStore(useShallow((state) => [state.exampleState3, state.exampleAction5]))
See docs/pages/develop/store.mdx for more state management best practices

[State Derivation & Hooks]
PREFER DERIVED STATE over useState and useEffect whenever possible. Derive state from existing state or props.
Create meaningful custom hooks to extract complex logic from pages. Place them in the hooks/ folder.
Custom hooks should be focused, reusable, and testable. They should encapsulate specific business logic.
Use useMemo and useCallback judiciously - only when you have performance issues or need referential equality.
Avoid useEffect for state synchronization - prefer derived state or custom hooks instead.
When you must use useEffect, ensure it has proper dependencies and cleanup.

[Utility Functions]
Create utility functions for reusable business logic. Place them in the utils/ folder.
Utility functions should be pure functions when possible (no side effects, same input = same output).
Group related utility functions in the same file (e.g., validation.ts, format.ts, crypto.ts).
Utility functions should be well-typed and documented with JSDoc if complex.
Avoid duplicating logic across components - extract to utilities or hooks.

[Testing Requirements]
Write unit tests for all utility functions in tests/unit/utils/
Write unit tests for custom hooks in tests/unit/hooks/
Write unit tests for complex business logic in store actions
Test files should be co-located with the code they test (same folder structure)
Use descriptive test names that explain the expected behavior
Test both happy path and edge cases
Mock external dependencies appropriately

[Documentation & Comments]
Document complex flows, business logic, and architectural decisions in external documentation files
Add JSDoc comments to complex utility functions and custom hooks
Add JSDoc comments to complex store actions and selectors
DO NOT add unnecessary comments that just restate what the code does
Comments should explain WHY, not WHAT
Document any non-obvious business rules or constraints

[Code Organization & Architecture]
Think about if the code you just wrote is in the right place - is it a utility, hook, component, or page logic?
Ensure code is readable and testable - break down complex functions into smaller, focused functions
Prefer composition over inheritance
Keep functions small and focused on a single responsibility
Use meaningful variable and function names that clearly express intent

[Pull Request Guidelines]
Prefer small to medium PRs instead of large ones
Each PR should focus on a single feature or bug fix
Break down large features into smaller, reviewable chunks
Include tests for new functionality
Update documentation if adding new features or changing behavior

[TSX]
Don't add spaces between component/react native tags
Prioritize using already created layouts and components. Layouts components are under layouts folder and components under components folder.

[Components]
Components and layouts are prefixed with "SS"
Follow the component anatomy & best practices described in docs/pages/develop/components.mdx
Components should be focused and reusable
Extract complex component logic into custom hooks
Keep components as presentational as possible

[Pages]
Inside the app folder is where our pages are.
Prioritize using inline styles for overriding components defaults before creating const styles = StyleSheet.create
Organize the code inside the page - this is very important - first declare hooks, then use zustand stores, then useState and useMemo/useCallback then useEffects/useFocusEffect/function declarations - finally the jsx
Avoid creating unnecessary state with useState and overuse useEffect
Extract complex page logic into custom hooks
Keep pages focused on UI composition and user interactions

[Storage]
Use storage/encrypted to store things in keychain securely
Use storage/mmkv for fast read/write (fully synchronous)

[API]
We put api logic inside api folder
Pages code should call these functions and local state (with useState)/zustand should handle the state
API functions should be pure and focused on data fetching/transformation
Handle errors appropriately in API functions

[Constants]
Add/update constants inside the constants folder
Use uppercase with underscores for constants: ELECTRUM_URL
Group related constants together

[Code Quality Standards]
Follow satsigner's existing code standards
Use function keyword for function declarations
Prefer types over interfaces
Avoid 'any' type at all costs
Use proper TypeScript types and avoid type assertions when possible
Import types with 'type' keyword: import { type Block } from '...'

[Before Committing]
Remove console.logs
Run the linter: yarn lint:fix
Run the formatter: yarn format:fix
Run type-checking: yarn type-check
Run tests: yarn test
Ensure all new code has appropriate tests
